/*
Copyright (C) 2012-2025 Tencent. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

// This file contains a collection of methods that can be used from go-restful to
// generate Swagger API documentation for its models. Please read this PR for more
// information on the implementation: https://github.com/emicklei/go-restful/pull/215
//
// TODOs are ignored from the parser (e.g. TODO(andronat):... || TODO:...) if and only if
// they are on one line! For multiple line or blocks that you want to ignore use ---.
// Any context after a --- is ignored.
//
// Those methods can be generated by using scripts/update-generated-swagger-docs.sh

// AUTO-GENERATED FUNCTIONS START HERE. DO NOT EDIT.
var map_AutoUpgradeOptions = map[string]string{
	"":                     "AutoUpgradeOptions defines the set of options for the user to control how the Auto Upgrades will proceed.",
	"autoUpgradeStartTime": "AutoUpgradeStartTime is set when upgrades are about to commence with the approximate start time for the upgrades, in RFC3339 (https://www.ietf.org/rfc/rfc3339.txt) text format.",
	"duration":             "Maintenance duration time, default 2h Example: 3h",
	"weeklyPeriod":         "WeeklyPeriod is the days to do the maintenance job. Example: Wednesday,Thursday",
}

func (AutoUpgradeOptions) SwaggerDoc() map[string]string {
	return map_AutoUpgradeOptions
}

var map_RollingUpgrade = map[string]string{
	"":         "RollingUpgrade is the Schema for the rollingupgrades API.",
	"metadata": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
	"spec":     "Specification of the desired behavior for this RollingUpgrade.",
}

func (RollingUpgrade) SwaggerDoc() map[string]string {
	return map_RollingUpgrade
}

var map_RollingUpgradeCondition = map[string]string{
	"": "RollingUpgradeCondition describes the state of the RollingUpgrade",
}

func (RollingUpgradeCondition) SwaggerDoc() map[string]string {
	return map_RollingUpgradeCondition
}

var map_RollingUpgradeList = map[string]string{
	"": "RollingUpgradeList contains a list of RollingUpgrade.",
}

func (RollingUpgradeList) SwaggerDoc() map[string]string {
	return map_RollingUpgradeList
}

var map_RollingUpgradeSpec = map[string]string{
	"":               "RollingUpgradeSpec defines the desired state of RollingUpgrade.",
	"machineSetName": "MachineSetName specify the name of the machineset for this rollingupgrade.",
	"autoUpgrade":    "AutoUpgrade specifies whether node auto-upgrade is enabled for the node pool. If enabled, node auto-upgrade helps keep the nodes in your node pool up to date with the latest release version of Kubernetes.",
	"upgradeOptions": "UpgradeOptions Specifies the Auto Upgrade knobs for the node pool.",
	"components":     "Components defines which component to upgrade when available",
}

func (RollingUpgradeSpec) SwaggerDoc() map[string]string {
	return map_RollingUpgradeSpec
}

var map_RollingUpgradeStatus = map[string]string{
	"": "RollingUpgradeStatus defines the observed state of RollingUpgrade.",
}

func (RollingUpgradeStatus) SwaggerDoc() map[string]string {
	return map_RollingUpgradeStatus
}

var map_UpdateStrategy = map[string]string{
	"":               "UpdateStrategy holds the information needed to perform update based on different update strategies",
	"maxUnavailable": "The maximum number of machines that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 25%.",
}

func (UpdateStrategy) SwaggerDoc() map[string]string {
	return map_UpdateStrategy
}

var map_CXMDisk = map[string]string{
	"":                      "CXMDisk describes disks for CXM.",
	"diskType":              "DiskType is the type of the disk (eg: pd-standard). Default: CloudPremiumDiskType. SystemDisk and DataDisk share this field.",
	"diskSize":              "DiskSize is the size of the disk (in GB). SystemDisk and DataDisk share this field.",
	"diskID":                "DiskID is the id of the disk. SystemDisk and DataDisk share this field This value is set automatically at runtime and should not be set or modified by users.",
	"deleteWithInstance":    "DeleteWithInstance indicates if the disk will be auto-deleted when the instance is deleted (default false).",
	"autoFormatAndMount":    "AutoFormatAndMount specify whether automatic format and mount this disk by tke. When AutoFormatAndMount is true, `FileSystem` and `MountTarget` must be specified.",
	"fileSystem":            "FileSystem specify the filesystem used by this disk. Different file systems will be selected according to different operating systems.",
	"mountTarget":           "MountTarget specify where to mount this disk.",
	"encrypt":               "Encrypt specify whether to encrypt this disk.",
	"kmsKeyId":              "KmsKeyId specify the KMS key used to encrypt this disk.",
	"snapshotId":            "SnapshotId specify the snapshot id used to create this disk.",
	"throughputPerformance": "ThroughputPerformance specify the throughput performance of this disk.",
	"DiskPartition":         "DiskPartition specify use device name mount disk",
	"imageCacheId":          "ImageCacheId specify image cache id with snapshot reference https://cloud.tencent.com/document/product/457/65908",
}

func (CXMDisk) SwaggerDoc() map[string]string {
	return map_CXMDisk
}

var map_CXMMachineProviderSpec = map[string]string{
	"":                      "CXMMachineProviderSpec is the type that will be embedded in a Machine.Spec.ProviderSpec field for an CXM virtual machine. It is used by the CXM machine actuator to create a single Machine. Compatibility level 2: Stable within a major release for a minimum of 9 months or 3 minor releases (whichever is longer).",
	"lifecycle":             "Lifecycle allow users to operations on the node before/after the node initialization.",
	"management":            "Management contains list of items need to operation on the node. Difference management type have different behavior.",
	"instanceType":          "InstanceType is the vm instanceType selected to create the instance. If the `instanceType` in `placement` also exists, this will be used first.",
	"instanceChargeType":    "Instance billing plan. Default: PostpaidByHourChargeType optional",
	"instanceChargePrepaid": "Configuration of prepaid instances. You can use the parameter to specify the attributes of prepaid instances, such as the subscription period and the auto-renewalplan. It is required if the `InstanceChargeType` is `PrepaidChargeType`.",
	"securityGroupIDs":      "SecurityGroupIDs is a list of Tencent Cloud Security Group ID.",
	"systemDisk":            "Configuration of the system disk of the instance.",
	"dataDisks":             "SystemDisk is a list of data disk.",
	"keyIDs":                "Tencent Cloud SSH IDs. After an instance is associated with a key, you can access the instance with the private key in the key pair. You can call [`DescribeKeyPairs`](https://intl. cloud.tencent.com/document/api/213/15699?from_cn_redirect=1) to obtain `KeyId`. A key and password cannot be specified at the same time. Currently, you can only specify one key when purchasing an instance.",
	"internetAccessible":    "InternetAccessible is the network configuration used to create network interface for the node.",
	"hostName":              "If this value is an empty stringï¼Œ\n  the displayName of the node is tke tke-${machineSetName}-work,\n  os hostName is generated by cxm server,\n  k8s nodeName is the internal IP address.\nIf this value is a non empty string,\n  the machine's displayName, os hostName, and k8s nodeName are all generated based on\n  the HostNamePattern annotate(node.tke.cloud.tencent.com/hostname-pattern) of machineSet.",
	"hpcClusterId":          "HpcClusterId is the ID of the HPC cluster to which the instance belongs.",
}

func (CXMMachineProviderSpec) SwaggerDoc() map[string]string {
	return map_CXMMachineProviderSpec
}

var map_CXMMachineProviderStatus = map[string]string{
	"":                  "CXMMachineProviderStatus is the type that will be embedded in a Machine.Status.ProviderStatus field. It contains CXM-specific status information. Compatibility level 2: Stable within a major release for a minimum of 9 months or 3 minor releases (whichever is longer).",
	"instanceID":        "InstanceID is the ID of the instance in CXM",
	"hostName":          "HostName is the hostName of the instance",
	"displayName":       "DisplayName is the displayName of the instance",
	"uuid":              "Globally unique ID of the instance.",
	"conditions":        "Conditions is a set of conditions associated with the Machine to indicate errors or other status",
	"taskRef":           "TaskRef is a managed object reference to a Task related to the machine. This value is set automatically at runtime and should not be set or modified by users.",
	"lastManagement":    "LastManagement record the last management configuration. machine-lifecircle-controller use this field to obtain the change information by comparing it with the current configuration.",
	"maintenanceStatus": "Node operation and maintenance status. This field is maintained by machine-lifecircle-controller Available values: Initializing, InitFailed, Initialized, Upgrading, Repairing, UpgradeFailed",
	"systemDisk":        "SystemDisk is the system disk of the instance.",
}

func (CXMMachineProviderStatus) SwaggerDoc() map[string]string {
	return map_CXMMachineProviderStatus
}

var map_EnhancedService = map[string]string{
	"":                "EnhancedService contains Tencent Cloud services can be enabled.",
	"monitorService":  "Enables cloud monitor service. If this parameter is not specified, the cloud monitor service will be enabled by default.",
	"securityService": "Enables cloud security service. If this parameter is not specified, the cloud security service will be enabled by default.",
}

func (EnhancedService) SwaggerDoc() map[string]string {
	return map_EnhancedService
}

var map_InstanceChargePrepaid = map[string]string{
	"period":    "Subscription period; unit: month; valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36.",
	"renewFlag": "Auto renewal flag. Valid values: NotifyAndAutoRenew, NotifyAndManualRenew, DisableNotifyAndManualRenew. Default: NotifyAndManualRenew.",
}

func (InstanceChargePrepaid) SwaggerDoc() map[string]string {
	return map_InstanceChargePrepaid
}

var map_InternetAccessible = map[string]string{
	"":                   "InternetAccessible describes network interfaces for CXM.",
	"maxBandwidthOut":    "The maximum outbound bandwidth of the public network, in Mbps. The default value is 1 Mbps. For more information, see [Purchase Network Bandwidth](https://intl.cloud.tencent.com/document/product/213/12523?from_cn_redirect=1).",
	"chargeType":         "ChargeType specify the network connection billing plan. Default `TrafficPostpaidByHour`",
	"addressID":          "The ID of the EIP instance, like `eip-hxlqja90`.",
	"bandwidthPackageID": "Bandwidth package ID. To obatin the IDs.",
	"publicIPAssigned":   "PublicIPAssigned indicates whether the public IP is assigned to the instance.",
	"addressType":        "Resource type of the EIP, including `EIP` (elastic IP).",
}

func (InternetAccessible) SwaggerDoc() map[string]string {
	return map_InternetAccessible
}

var map_LifecycleConfig = map[string]string{
	"preInit":  "PreInit hooks will be executed before node initialization.",
	"postInit": "PostInit hooks will be executed after node initialization.",
}

func (LifecycleConfig) SwaggerDoc() map[string]string {
	return map_LifecycleConfig
}

var map_ManagementConfig = map[string]string{
	"":            "ManagementConfig defines the content of automatic operation and maintenance.",
	"nameservers": "DNS nameservers.",
	"hosts":       "Hosts is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.",
	"kernelArgs":  "Custom linux kernel arguments.",
	"kubeletArgs": "Custom kubernetes kubelet arguments.",
}

func (ManagementConfig) SwaggerDoc() map[string]string {
	return map_ManagementConfig
}

var map_MachinSetScaling = map[string]string{
	"":             "MachinSetScaling  specifies scaling options.",
	"minReplicas":  "MinReplicas constrains the minimal number of replicas of a scalable resource",
	"maxReplicas":  "MaxReplicas constrains the maximal number of replicas of a scalable resource",
	"createPolicy": "CreatePolicy defines the machine create policy when create machine, default ZoneEquality",
}

func (MachinSetScaling) SwaggerDoc() map[string]string {
	return map_MachinSetScaling
}

var map_MachineRollingUpdateStrategy = map[string]string{
	"":                     "MachineUpdateStrategy defines rolling update machine params strategy",
	"maxConfigUnavailable": "MaxConfigUnavailable indicates the maximum config unavailable number of updated nodes in the node pool, including update failed or updating",
	"maxSteps":             "MaxSteps indicates the maximum number of nodes that can be updated simultaneously in a single update round",
}

func (MachineRollingUpdateStrategy) SwaggerDoc() map[string]string {
	return map_MachineRollingUpdateStrategy
}

var map_MachineSet = map[string]string{
	"": "MachineSet ensures that a specified number of machines replicas are running at any given time.",
}

func (MachineSet) SwaggerDoc() map[string]string {
	return map_MachineSet
}

var map_MachineSetCondition = map[string]string{
	"":                   "MachineSetCondition describes the state of a replica set at a certain point.",
	"type":               "Type of replica set condition.",
	"status":             "Status of the condition, one of True, False, Unknown.",
	"lastTransitionTime": "The last time the condition transitioned from one status to another.",
	"reason":             "The reason for the condition's last transition.",
	"message":            "A human readable message indicating details about the transition.",
}

func (MachineSetCondition) SwaggerDoc() map[string]string {
	return map_MachineSetCondition
}

var map_MachineSetList = map[string]string{
	"": "MachineSetList contains a list of MachineSet Compatibility level 2: Stable within a major release for a minimum of 9 months or 3 minor releases (whichever is longer).",
}

func (MachineSetList) SwaggerDoc() map[string]string {
	return map_MachineSetList
}

var map_MachineSetSpec = map[string]string{
	"":                      "MachineSetSpec defines the desired state of MachineSet",
	"type":                  "MachineSetType is the type of this MachineSet. Different types have different operation and maintenance policy.",
	"displayName":           "The display name of the machineset.",
	"replicas":              "Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1.",
	"selector":              "Selector is a label query over machines that should match the replica count. Label keys and values that must match in order to be controlled by this MachineSet. It must match the machine template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
	"template":              "Template is the object that describes the machine that will be created if insufficient replicas are detected.",
	"healthCheckPolicyName": "HealthCheckPolicyName is the healthcheckpolicy name used by this machineset. When created, the latest healthcheckpolicy resource version will be recorded in `healthCheckPolicyResourceVersion` in the status field.",
	"minReadySeconds":       "MinReadySeconds is the minimum number of seconds for which a newly created machine should be ready. Defaults to 0 (machine will be considered available as soon as it is ready)",
	"deletePolicy":          "DeletePolicy defines the policy used to identify nodes to delete when downscaling. Defaults to \"Random\".  Valid values are \"Random, \"Newest\", \"Oldest\"",
	"subnetIDs":             "SubnetIDs is an array of subnets used by the specified instances.",
	"instanceTypes":         "InstanceTypes specifies the tke instance types.",
	"scaling":               "Scaling is the machine autoscaler configuration for this machineset.",
	"autoRepair":            "AutoRepair specifies whether the node auto-repair is enabled for the node pool. If enabled, the nodes in this node pool will be monitored and, if they fail health checks too many times, an automatic repair action will be triggered.",
	"gpuConfigs":            "GPUConfigs stores message of Gpu driver version installed in machine",
	"keyID":                 "KeyID stores machine set ssh public key id",
	"machineUpdateStrategy": "MachineUpdateStrategy store update specified machine params strategy",
}

func (MachineSetSpec) SwaggerDoc() map[string]string {
	return map_MachineSetSpec
}

var map_MachineSetStatus = map[string]string{
	"":                          "MachineSetStatus defines the observed state of MachineSet.",
	"healthCheckPolicyRevision": "HealthCheckPolicyResourceVersion record the healthcheckpolicy resource version used by this machineset. This value is set automatically at runtime and should not be set or modified by users.",
	"replicas":                  "Replicas is the most recently observed number of replicas.",
	"fullyLabeledReplicas":      "The number of replicas that have labels matching the labels of the machine template of the MachineSet.",
	"readyReplicas":             "The number of ready replicas for this MachineSet. A machine is considered ready when the node has been created and is \"Ready\".",
	"availableReplicas":         "The number of available replicas (ready for at least minReadySeconds) for this MachineSet.",
	"observedGeneration":        "ObservedGeneration reflects the generation of the most recently observed MachineSet.",
	"kubeletVersion":            "Kubelet version is the kubelet version of the machineset This value is set automatically at runtime and should not be set or modified by users.",
	"runtimeVersion":            "Runtime version is the runtime version of the machineset This value is set automatically at runtime and should not be set or modified by users.",
	"conditions":                "Represents the latest available observations of a machine set's current state.",
}

func (MachineSetStatus) SwaggerDoc() map[string]string {
	return map_MachineSetStatus
}

var map_MachineTemplateSpec = map[string]string{
	"":         "MachineTemplateSpec describes the data needed to create a Machine from a template",
	"metadata": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
	"spec":     "Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
}

func (MachineTemplateSpec) SwaggerDoc() map[string]string {
	return map_MachineTemplateSpec
}

var map_MachineUpdateStrategy = map[string]string{
	"":              "MachineUpdateStrategy defines update machine params strategy",
	"type":          "currently only one type: RollingUpdate",
	"rollingUpdate": "When the type is RollingUpdate, the RollingUpdate field works",
}

func (MachineUpdateStrategy) SwaggerDoc() map[string]string {
	return map_MachineUpdateStrategy
}

var map_LastOperation = map[string]string{
	"":            "LastOperation represents the detail of the last performed operation on the MachineObject.",
	"description": "Description is the human-readable description of the last operation.",
	"lastUpdated": "LastUpdated is the timestamp at which LastOperation API was last-updated.",
	"state":       "State is the current status of the last performed operation. E.g. Processing, Failed, Successful etc",
	"type":        "Type is the type of operation which was last performed. E.g. Create, Delete, Update etc",
}

func (LastOperation) SwaggerDoc() map[string]string {
	return map_LastOperation
}

var map_LifecycleHook = map[string]string{
	"":      "LifecycleHook represents a single instance of a lifecycle hook",
	"name":  "Name defines a unique name for the lifcycle hook. The name should be unique and descriptive, ideally 1-3 words, in CamelCase or it may be namespaced, eg. foo.example.com/CamelCase. Names must be unique and should only be managed by a single entity.",
	"owner": "Owner defines the owner of the lifecycle hook. This should be descriptive enough so that users can identify who/what is responsible for blocking the lifecycle. This could be the name of a controller (e.g. clusteroperator/etcd) or an administrator managing the hook.",
}

func (LifecycleHook) SwaggerDoc() map[string]string {
	return map_LifecycleHook
}

var map_Machine = map[string]string{
	"": "Machine is the Schema for the machines API.",
}

func (Machine) SwaggerDoc() map[string]string {
	return map_Machine
}

var map_MachineList = map[string]string{
	"": "MachineList contains a list of Machine Compatibility level 2: Stable within a major release for a minimum of 9 months or 3 minor releases (whichever is longer).",
}

func (MachineList) SwaggerDoc() map[string]string {
	return map_MachineList
}

var map_MachineSpec = map[string]string{
	"":               "MachineSpec defines the desired state of Machine",
	"metadata":       "ObjectMeta will autopopulate the Node created. Use this to indicate what labels, annotations, name prefix, etc., should be used when creating the Node.",
	"displayName":    "The display name of the machine.",
	"zone":           "Zone is the availability zone used to create the instance.",
	"subnetID":       "VPC subnet ID in the format `subnet-xxx`. If the `subnetID` in `placement` also exists, this will be used first.",
	"taints":         "The list of the taints to be applied to the corresponding Node in additive manner. This list will not overwrite any other taints added to the Node on an ongoing basis by other entities. These taints should be actively reconciled e.g. if you ask the machine controller to apply a taint and then manually remove the taint the machine controller will put it back) but not have the machine controller remove any taints",
	"runtimeRootDir": "Specified value of containerd --graph. Default value: /var/lib/docker",
	"kubeletVersion": "Kubelet version is the kubelet version of the machine. This field is maintained by the cloud vendor and will be populated with the latest version corresponding to the cluster version. You should not set this field.",
	"runtimeVersion": "Runtime version is the runtime version of the machine. This field is maintained by the cloud vendor and will be populated with the latest version corresponding to the cluster version. You should not set this field.",
	"gpuConfig":      "GPUConfig is the gpu driver version of the machine.",
	"unschedulable":  "Sets whether the added node is schedulable. Default false. After node initialization is completed, you can run kubectl uncordon $nodename to enable this node for scheduling.",
	"providerSpec":   "ProviderSpec details Provider-specific configuration to use during node creation.",
	"providerID":     "ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver and then a comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler that will be interfacing with cluster-api as generic provider.",
}

func (MachineSpec) SwaggerDoc() map[string]string {
	return map_MachineSpec
}

var map_MachineStatus = map[string]string{
	"":               "MachineStatus defines the observed state of Machine",
	"nodeRef":        "NodeRef will point to the corresponding Node if it exists.",
	"lastUpdated":    "LastUpdated identifies when this status was last observed.",
	"failureReason":  "FailureReason will be set in the event that there is a terminal problem reconciling the Machine and will contain a succinct value suitable for machine interpretation.\n\nThis field should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the Machine's spec or the configuration of the controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the controller, or the responsible controller itself being critically misconfigured.\n\nAny transient errors that occur during the reconciliation of Machines can be added as events to the Machine object and/or logged in the controller's output.",
	"failureMessage": "FailureMessage will be set in the event that there is a terminal problem reconciling the Machine and will contain a more verbose string suitable for logging and human consumption.\n\nThis field should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the Machine's spec or the configuration of the controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the controller, or the responsible controller itself being critically misconfigured.\n\nAny transient errors that occur during the reconciliation of Machines can be added as events to the Machine object and/or logged in the controller's output.",
	"providerStatus": "ProviderStatus details a Provider-specific status. It is recommended that providers maintain their own versioned API types that should be serialized/deserialized from this field.",
	"addresses":      "Addresses is a list of addresses assigned to the machine. Queried from cloud provider, if available.",
	"lastOperation":  "LastOperation describes the last-operation performed by the machine-controller. This API should be useful as a history in terms of the latest operation performed on the specific machine. It should also convey the state of the latest-operation for example if it is still on-going, failed or completed successfully.",
	"phase":          "Phase represents the current phase of machine actuation. One of: Failed, Provisioning, Provisioned, Running, Deleting This field is maintained by machine controller.",
	"conditions":     "Conditions defines the current state of the Machine",
}

func (MachineStatus) SwaggerDoc() map[string]string {
	return map_MachineStatus
}

var map_NodeReference = map[string]string{
	"":               "NodeReference contains enough information to let you locate the referenced object inside the same namespace.",
	"name":           "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
	"osImage":        "OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).",
	"architecture":   "The Architecture reported by the node.",
	"kubeletVersion": "KubeletVersion reported by the node.",
	"runtimeVersion": "RuntimeVersion reported by the node.",
}

func (NodeReference) SwaggerDoc() map[string]string {
	return map_NodeReference
}

var map_TagSpecification = map[string]string{
	"":      "TagSpecification is the name/value pair for a tag.",
	"name":  "Name of the tag",
	"value": "Value of the tag",
}

func (TagSpecification) SwaggerDoc() map[string]string {
	return map_TagSpecification
}

var map_FakeVMMachineProviderCondition = map[string]string{
	"":                   "FakeVMMachineProviderCondition is a condition in a FakeVMMachineProviderStatus.",
	"type":               "Type is the type of the condition.",
	"status":             "Status is the status of the condition.",
	"lastProbeTime":      "LastProbeTime is the last time we probed the condition.",
	"lastTransitionTime": "LastTransitionTime is the last time the condition transitioned from one status to another.",
	"reason":             "Reason is a unique, one-word, CamelCase reason for the condition's last transition.",
	"message":            "Message is a human-readable message indicating details about last transition.",
}

func (FakeVMMachineProviderCondition) SwaggerDoc() map[string]string {
	return map_FakeVMMachineProviderCondition
}

var map_FakeVMMachineProviderSpec = map[string]string{
	"":                  "FakeVMMachineProviderSpec is the type that will be embedded in a Machine.Spec.ProviderSpec field for an fakevm virtual machine. It is used by the fakevm machine actuator to create a single Machine. Compatibility level 2: Stable within a major release for a minimum of 9 months or 3 minor releases (whichever is longer).",
	"userDataSecret":    "UserDataSecret contains a local reference to a secret that contains the UserData to apply to the instance",
	"credentialsSecret": "CredentialsSecret is a reference to the secret with fakevm credentials.",
	"template":          "Template is the name, inventory path, or instance UUID of the template used to clone new machines.",
	"workspace":         "Workspace describes the workspace to use for the machine.",
	"network":           "Network is the network configuration for this machine's VM.",
	"numCPUs":           "NumCPUs is the number of virtual processors in a virtual machine. Defaults to the analogue property value in the template from which this machine is cloned.",
	"numCoresPerSocket": "NumCPUs is the number of cores among which to distribute CPUs in this virtual machine. Defaults to the analogue property value in the template from which this machine is cloned.",
	"memoryMiB":         "MemoryMiB is the size of a virtual machine's memory, in MiB. Defaults to the analogue property value in the template from which this machine is cloned.",
	"diskGiB":           "DiskGiB is the size of a virtual machine's disk, in GiB. Defaults to the analogue property value in the template from which this machine is cloned.",
	"snapshot":          "Snapshot is the name of the snapshot from which the VM was cloned",
	"cloneMode":         "CloneMode specifies the type of clone operation. The LinkedClone mode is only support for templates that have at least one snapshot. If the template has no snapshots, then CloneMode defaults to FullClone. When LinkedClone mode is enabled the DiskGiB field is ignored as it is not possible to expand disks of linked clones. Defaults to LinkedClone, but fails gracefully to FullClone if the source of the clone operation has no snapshots.",
}

func (FakeVMMachineProviderSpec) SwaggerDoc() map[string]string {
	return map_FakeVMMachineProviderSpec
}

var map_FakeVMMachineProviderStatus = map[string]string{
	"":              "FakeVMMachineProviderStatus is the type that will be embedded in a Machine.Status.ProviderStatus field. It contains FakeVM-specific status information. Compatibility level 2: Stable within a major release for a minimum of 9 months or 3 minor releases (whichever is longer).",
	"instanceId":    "InstanceID is the ID of the instance in FakeVM",
	"instanceState": "InstanceState is the provisioning state of the FakeVM Instance.",
	"conditions":    "Conditions is a set of conditions associated with the Machine to indicate errors or other status",
	"taskRef":       "TaskRef is a managed object reference to a Task related to the machine. This value is set automatically at runtime and should not be set or modified by users.",
}

func (FakeVMMachineProviderStatus) SwaggerDoc() map[string]string {
	return map_FakeVMMachineProviderStatus
}

var map_NetworkDeviceSpec = map[string]string{
	"":            "NetworkDeviceSpec defines the network configuration for a virtual machine's network device.",
	"networkName": "NetworkName is the name of the fakevm network to which the device will be connected.",
}

func (NetworkDeviceSpec) SwaggerDoc() map[string]string {
	return map_NetworkDeviceSpec
}

var map_NetworkSpec = map[string]string{
	"":        "NetworkSpec defines the virtual machine's network configuration.",
	"devices": "Devices defines the virtual machine's network interfaces.",
}

func (NetworkSpec) SwaggerDoc() map[string]string {
	return map_NetworkSpec
}

var map_Workspace = map[string]string{
	"":             "WorkspaceConfig defines a workspace configuration for the fakevm cloud provider.",
	"server":       "Server is the IP address or FQDN of the fakevm endpoint.",
	"datacenter":   "Datacenter is the datacenter in which VMs are created/located.",
	"folder":       "Folder is the folder in which VMs are created/located.",
	"datastore":    "Datastore is the datastore in which VMs are created/located.",
	"resourcePool": "ResourcePool is the resource pool in which VMs are created/located.",
}

func (Workspace) SwaggerDoc() map[string]string {
	return map_Workspace
}

// AUTO-GENERATED FUNCTIONS END HERE
